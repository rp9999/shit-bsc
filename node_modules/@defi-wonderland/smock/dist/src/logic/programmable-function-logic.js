"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeProgrammableContract = exports.ProgrammableFunctionLogic = void 0;
const exceptions_1 = require("@nomiclabs/ethereumjs-vm/dist/exceptions");
const bn_js_1 = __importDefault(require("bn.js"));
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const rxjs_1 = require("rxjs");
const watchable_function_logic_1 = require("../logic/watchable-function-logic");
const utils_1 = require("../utils");
const EMPTY_ANSWER = utils_1.fromHexString('0x' + '00'.repeat(2048));
class ProgrammedAnswer {
    constructor(value, shouldRevert = false) {
        this.value = value;
        this.shouldRevert = shouldRevert;
    }
}
class ProgrammableFunctionLogic extends watchable_function_logic_1.WatchableFunctionLogic {
    constructor(name, calls$, results$, encoder) {
        super(name, calls$);
        this.answerByIndex = {};
        this.answerByArgs = [];
        this.encoder = encoder;
        results$.pipe(rxjs_1.withLatestFrom(calls$)).subscribe(async ([result, call]) => {
            await this.modifyAnswer(result, call);
        });
    }
    returns(value) {
        this.defaultAnswer = new ProgrammedAnswer(value, false);
    }
    returnsAtCall(callIndex, value) {
        this.answerByIndex[callIndex] = new ProgrammedAnswer(value, false);
    }
    whenCalledWith(...args) {
        return {
            returns: (value) => {
                this.answerByArgs.push({
                    args,
                    answer: new ProgrammedAnswer(value, false),
                });
            },
            reverts: (reason) => {
                this.answerByArgs.push({
                    args,
                    answer: new ProgrammedAnswer(reason, true),
                });
            },
        };
    }
    reverts(reason) {
        this.defaultAnswer = new ProgrammedAnswer(reason, true);
    }
    revertsAtCall(callIndex, reason) {
        this.answerByIndex[callIndex] = new ProgrammedAnswer(reason, true);
    }
    reset() {
        super.reset();
        this.defaultAnswer = undefined;
        this.answerByIndex = {};
        this.answerByArgs = [];
    }
    async modifyAnswer(result, call) {
        const answer = this.getCallAnswer(call);
        if (answer) {
            result.gasUsed = new bn_js_1.default(0);
            result.execResult.gasUsed = new bn_js_1.default(0);
            if (answer.shouldRevert) {
                result.execResult.exceptionError = new exceptions_1.VmError('smock revert');
                result.execResult.returnValue = this.encodeRevertReason(answer.value);
            }
            else {
                result.execResult.exceptionError = undefined;
                result.execResult.returnValue = await this.encodeValue(answer.value, call);
            }
        }
    }
    getCallAnswer(call) {
        var _a;
        let answer;
        answer = this.answerByIndex[this.getCallCount() - 1];
        if (answer)
            return answer;
        answer = (_a = lodash_1.findLast(this.answerByArgs, (option) => this.isDeepEqual(option.args, call.args))) === null || _a === void 0 ? void 0 : _a.answer;
        if (answer)
            return answer;
        return this.defaultAnswer;
    }
    async encodeValue(value, call) {
        if (value === undefined)
            return EMPTY_ANSWER;
        let toEncode = typeof value === 'function' ? await value(call.args) : value;
        let encodedReturnValue = '0x';
        try {
            encodedReturnValue = this.encoder(toEncode);
        }
        catch (err) {
            if (err.code === 'INVALID_ARGUMENT') {
                if (typeof toEncode !== 'string') {
                    throw new Error(`Failed to encode return value for ${this.name}`);
                }
                encodedReturnValue = toEncode;
            }
            else {
                throw err;
            }
        }
        return utils_1.fromHexString(encodedReturnValue);
    }
    encodeRevertReason(reason) {
        if (reason === undefined)
            return EMPTY_ANSWER;
        const errorInterface = new ethers_1.ethers.utils.Interface([
            {
                inputs: [
                    {
                        name: '_reason',
                        type: 'string',
                    },
                ],
                name: 'Error',
                outputs: [],
                stateMutability: 'nonpayable',
                type: 'function',
            },
        ]);
        return utils_1.fromHexString(errorInterface.encodeFunctionData('Error', [reason]));
    }
}
exports.ProgrammableFunctionLogic = ProgrammableFunctionLogic;
class SafeProgrammableContract extends ProgrammableFunctionLogic {
    constructor() {
        super(...arguments);
        this.defaultAnswer = new ProgrammedAnswer();
    }
    reset() {
        super.reset();
        this.defaultAnswer = new ProgrammedAnswer();
    }
}
exports.SafeProgrammableContract = SafeProgrammableContract;
//# sourceMappingURL=programmable-function-logic.js.map