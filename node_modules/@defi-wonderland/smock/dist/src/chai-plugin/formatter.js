'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatters = void 0;
const diff_1 = require("diff");
const util_1 = require("util");
const utils_1 = require("../utils");
const color = __importStar(require("./color"));
function sinonFormat(...args) {
    return util_1.inspect(...args);
}
function colorSinonMatchText(matcher, calledArg, calledArgMessage) {
    var calledArgumentMessage = calledArgMessage;
    if (!matcher.test(calledArg)) {
        matcher.message = color.red(matcher.message);
        if (calledArgumentMessage) {
            calledArgumentMessage = color.green(calledArgumentMessage);
        }
    }
    return `${calledArgumentMessage} ${matcher.message}`;
}
function colorDiffText(diff) {
    var objects = diff.map((part) => {
        var text = part.value;
        if (part.added) {
            text = color.green(text);
        }
        else if (part.removed) {
            text = color.red(text);
        }
        if (diff.length === 2) {
            text += ' ';
        }
        return text;
    });
    return objects.join('');
}
function quoteStringValue(value) {
    if (typeof value === 'string') {
        return JSON.stringify(value);
    }
    return value;
}
exports.formatters = {
    c: (watchableContract) => {
        return utils_1.humanizeTimes(watchableContract.getCallCount());
    },
    n: (watchableContract) => {
        return watchableContract.getName();
    },
    D: (watchableContract, args) => {
        var message = '';
        for (var i = 0, l = watchableContract.getCallCount(); i < l; ++i) {
            if (l > 1) {
                message += `\nCall ${i + 1}:`;
            }
            var calledArgs = watchableContract.getCall(i).args;
            var expectedArgs = args.slice();
            for (var j = 0; j < calledArgs.length || j < expectedArgs.length; ++j) {
                let parsedCalledArgs = calledArgs[j];
                let parsedExpectedArgs = expectedArgs[j];
                if (parsedCalledArgs) {
                    if (utils_1.isStruct(parsedCalledArgs)) {
                        parsedCalledArgs = utils_1.convertStructToPojo(parsedCalledArgs);
                    }
                    parsedCalledArgs = quoteStringValue(parsedCalledArgs);
                }
                if (parsedExpectedArgs) {
                    parsedExpectedArgs = quoteStringValue(parsedExpectedArgs);
                }
                message += '\n';
                var calledArgMessage = j < calledArgs.length ? sinonFormat(parsedCalledArgs) : '';
                var expectedArgMessage = j < expectedArgs.length ? sinonFormat(parsedExpectedArgs) : '';
                var diff = diff_1.diffJson(calledArgMessage, expectedArgMessage);
                message += colorDiffText(diff);
            }
        }
        return message;
    },
    C: (watchableContract) => {
        let calls = [];
        for (var i = 0, l = watchableContract.getCallCount(); i < l; ++i) {
            var stringifiedCall = `    `;
            if (/\n/.test(calls[i - 1])) {
                stringifiedCall = `\n${stringifiedCall}`;
            }
            calls.push(stringifiedCall);
        }
        return calls.length > 0 ? `\n${calls.join('\n')}` : '';
    },
    t: (watchableContract) => {
        let objects = [];
        for (var i = 0, l = watchableContract.getCallCount(); i < l; ++i) {
        }
        return objects.join(', ');
    },
    '*': (watchableContract, args) => {
        return args.map((arg) => sinonFormat(arg)).join(', ');
    },
};
//# sourceMappingURL=formatter.js.map