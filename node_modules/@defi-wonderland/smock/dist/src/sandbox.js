"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sandbox = void 0;
const hardhat_1 = __importDefault(require("hardhat"));
const ethers_interface_1 = require("./factories/ethers-interface");
const smock_contract_1 = require("./factories/smock-contract");
const observable_vm_1 = require("./observable-vm");
const utils_1 = require("./utils");
let decodeRevertReason;
try {
    decodeRevertReason = require('hardhat/internal/hardhat-network/stack-traces/revert-reasons').decodeRevertReason;
}
catch (err) {
    const { ReturnData } = require('hardhat/internal/hardhat-network/provider/return-data');
    decodeRevertReason = (value) => {
        const returnData = new ReturnData(value);
        return returnData.isErrorReturnData() ? returnData.decodeError() : '';
    };
}
let TransactionExecutionError;
try {
    TransactionExecutionError = require('hardhat/internal/hardhat-network/provider/errors').TransactionExecutionError;
}
catch (err) {
    TransactionExecutionError = require('hardhat/internal/core/providers/errors').TransactionExecutionError;
}
class Sandbox {
    constructor(vm) {
        this.vm = new observable_vm_1.ObservableVM(vm);
    }
    async fake(spec, opts = {}) {
        return smock_contract_1.createFakeContract(this.vm, opts.address || utils_1.makeRandomAddress(), await ethers_interface_1.ethersInterfaceFromSpec(spec), opts.provider || hardhat_1.default.ethers.provider);
    }
    async mock(contractName, signerOrOptions) {
        return smock_contract_1.createMockContractFactory(this.vm, contractName, signerOrOptions);
    }
    static async create() {
        if (hardhat_1.default.network.name !== 'hardhat') {
            throw new Error(`Smock is only compatible with the "hardhat" network, got: ${hardhat_1.default.network.name}. Follow this issue for more info: https://github.com/defi-wonderland/smock/issues/29`);
        }
        const provider = await utils_1.getHardhatBaseProvider(hardhat_1.default);
        const node = provider._node;
        if (node === undefined) {
            await provider._init();
        }
        const originalManagerErrorsFn = node._manageErrors.bind(node);
        node._manageErrors = async (vmResult, vmTrace, vmTracerError) => {
            if (vmResult.exceptionError && vmResult.exceptionError.error === 'smock revert') {
                return new TransactionExecutionError(`VM Exception while processing transaction: revert ${decodeRevertReason(vmResult.returnValue)}`);
            }
            return originalManagerErrorsFn(vmResult, vmTrace, vmTracerError);
        };
        return new Sandbox(provider._node._vm);
    }
    static getNextNonce() {
        return Sandbox.nonce++;
    }
}
exports.Sandbox = Sandbox;
Sandbox.nonce = 0;
//# sourceMappingURL=sandbox.js.map